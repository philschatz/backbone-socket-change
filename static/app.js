// Generated by CoffeeScript 1.3.3
(function() {

  require.onError = function(err) {
    return console.error(err);
  };

  require.config({
    paths: {
      jquery: 'jquery-1.8.3',
      underscore: 'underscore/underscore',
      backbone: 'backbone/backbone',
      'socket-io': '/socket.io/socket.io'
    },
    shim: {
      underscore: {
        exports: '_'
      },
      backbone: {
        deps: ['underscore', 'jquery'],
        exports: 'Backbone'
      }
    }
  });

  define('app', ['underscore', 'backbone', 'socket-io'], function(_, Backbone, io) {
    var AllBackbone, AllCollectionsView, AllModelsView, CollectionModelView, FooModel, ModelView, SOCKET, syncWaiters, view;
    SOCKET = io.connect();
    AllBackbone = (function() {
      var ALL_COLLECTIONS, ALL_MODELS, CollectionModel, MODEL_CONSTRUCTORS;

      function AllBackbone() {}

      CollectionModel = Backbone.Model.extend({
        collection: null,
        initialize: function() {
          return this.id = this.get('collection').url;
        }
      });

      MODEL_CONSTRUCTORS = {};

      ALL_MODELS = new Backbone.Collection();

      ALL_COLLECTIONS = new Backbone.Collection();

      AllBackbone.prototype.newModel = function(constructorType, config, options) {
        var constructor, model;
        if (config.toJSON) {
          if (!ALL_MODELS.get(config.id)) {
            throw 'YOU CREATED A MODEL THAT WE DONT KNOW ABOUT';
          }
        }
        if (ALL_MODELS.get(config)) {
          return ALL_MODELS.get(config);
        }
        constructor = MODEL_CONSTRUCTORS[constructorType] || Backbone.Model;
        model = new constructor(config, {
          silent: true
        });
        ALL_MODELS.add(model, {
          remote: true
        });
        SOCKET.emit('MODEL', {
          name: 'new',
          config: config,
          options: options,
          constructorType: constructorType
        });
        return model;
      };

      AllBackbone.prototype.newCollection = function(url, options) {
        var grr, model;
        model = new Backbone.Collection();
        model.url = url;
        grr = new CollectionModel({
          id: url,
          collection: model
        }, {
          remote: true
        });
        ALL_COLLECTIONS.add(grr, {
          remote: true
        });
        if (!(options != null ? options.remote : void 0)) {
          SOCKET.emit('COLLECTION', {
            name: 'new',
            url: url,
            options: options
          });
        }
        return model;
      };

      AllBackbone.prototype.getModel = function(id) {
        return ALL_MODELS.get(id);
      };

      AllBackbone.prototype.getCollection = function(url) {
        var modelContainer;
        modelContainer = ALL_COLLECTIONS.get(url);
        return modelContainer.get('collection');
      };

      AllBackbone.prototype.modelIds = function() {
        return ALL_MODELS.map(function(model) {
          return model.id;
        });
      };

      AllBackbone.prototype.collectionUrls = function() {
        return ALL_COLLECTIONS.map(function(model) {
          return model.id;
        });
      };

      AllBackbone.prototype.setModelConstructor = function(typeName, constructor) {
        return MODEL_CONSTRUCTORS[typeName] = constructor;
      };

      AllBackbone.prototype._modelsAsCollection = ALL_MODELS;

      AllBackbone.prototype._collectionsAsCollection = ALL_COLLECTIONS;

      return AllBackbone;

    })();
    this.ALL_BACKBONE = new AllBackbone();
    FooModel = Backbone.Model.extend({
      url: '/fooUrl',
      toJSON: function() {
        return {
          id: this.id,
          foo: true
        };
      }
    });
    ALL_BACKBONE.setModelConstructor('FooModel', FooModel);
    syncWaiters = {};
    SOCKET.on('STATE', function(evt) {
      var cfg, collection, json, models, url, _i, _len, _ref, _ref1, _results;
      _ref = evt.models;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        json = _ref[_i];
        ALL_BACKBONE.newModel(json.type, json, {
          silent: true,
          remote: true
        });
      }
      _ref1 = evt.collections;
      _results = [];
      for (url in _ref1) {
        models = _ref1[url];
        models = (function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = models.length; _j < _len1; _j++) {
            cfg = models[_j];
            _results1.push(ALL_BACKBONE.getModel(cfg.id));
          }
          return _results1;
        })();
        collection = ALL_BACKBONE.newCollection(url, {
          remote: true
        });
        _results.push(collection.set(models, {
          silent: true,
          remote: true
        }));
      }
      return _results;
    });
    SOCKET.on('MODEL', function(evt) {
      var model, options;
      switch (evt.name) {
        case 'new':
          return ALL_BACKBONE.newModel(evt.type, evt.config);
        case 'change':
          model = ALL_BACKBONE.getModel(evt.id);
          if (!model) {
            throw "COULD NOT FIND MODEL WITH ID " + evt.id;
          }
          return model.set.call(model, evt.changedAttributes, _.extend(evt.options, {
            remote: true
          }));
        case 'sync':
          model = ALL_BACKBONE.getModel(evt.id);
          if (!model) {
            throw "COULD NOT FIND MODEL WITH ID " + evt.id;
          }
          if (syncWaiters[evt.id]) {
            options = syncWaiters[evt.id];
            delete syncWaiters[evt.id];
            switch (evt.status) {
              case 'done':
                return options != null ? typeof options.success === "function" ? options.success(evt.value, options) : void 0 : void 0;
              case 'fail':
                return options != null ? typeof options.error === "function" ? options.error(evt.value, options) : void 0 : void 0;
              default:
                throw 'INVALID STATUS FROM REMOTE Backbone.sync CALL';
            }
          }
          break;
        default:
          throw "UNMATCHED EVENT " + evt.name;
      }
    });
    SOCKET.on('COLLECTION', function(evt) {
      var collection, models;
      switch (evt.name) {
        case 'new':
          return ALL_BACKBONE.newCollection(evt.url, {
            remote: true
          });
        case 'change':
          collection = ALL_BACKBONE.getCollection(evt.url);
          if (!collection) {
            throw "COULD NOT FIND COLLECTION WITH URL " + evt.url;
          }
          models = _.map(evt.models, function(model) {
            return ALL_BACKBONE.getModel(model.id);
          });
          return collection.set(models, _.extend(evt.options, {
            remote: true
          }));
        default:
          throw "UNMATCHED EVENT " + evt.name;
      }
    });
    Backbone.sync = function(method, model, options) {
      var data;
      data = {
        id: model.id,
        name: 'sync',
        method: method,
        options: options
      };
      syncWaiters[model.id] = options;
      return SOCKET.emit('MODEL', data);
    };
    Backbone.Model.prototype._trigger = Backbone.Model.prototype.trigger;
    Backbone.Model.prototype.trigger = function(name, model) {
      var args, changeCollection, data, options;
      options = _.last(arguments);
      if (options.remote) {
        return this._trigger.apply(this, arguments);
      }
      args = _.rest(arguments, 2);
      changeCollection = function() {
        var collection, data;
        collection = args[0], options = args[1];
        data = {
          url: (typeof collection.url === "function" ? collection.url() : void 0) || collection.url || (function() {
            throw "COLLECTION MUST HAVE A URL";
          })()
        };
        data.name = 'change';
        data.models = collection.map(function(model) {
          return {
            id: model.id
          };
        });
        data.options = options;
        return SOCKET.emit('COLLECTION', data);
      };
      if (/^change:/.test(name)) {
        return this;
      }
      switch (name) {
        case 'change':
          data = {
            id: model.id || (function() {
              throw 'MODELS MUST HAVE AN ID';
            })()
          };
          data.name = 'change';
          data.changedAttributes = model.changedAttributes();
          data.options = args[0];
          SOCKET.emit('MODEL', data);
          break;
        case 'add':
          changeCollection();
          break;
        case 'remove':
          changeCollection();
          break;
        case 'reset':
          changeCollection();
          break;
        case 'error':
          if (typeof console !== "undefined" && console !== null) {
            console.error('LOCAL EVENT "error". Not sending to server');
          }
          break;
        default:
          throw "UNMATCHED EVENT " + name;
      }
      return this._trigger.apply(this, arguments);
    };
    ModelView = Backbone.View.extend({
      template: function(json) {
        return "<pre>" + (JSON.stringify(json)) + "</pre>";
      },
      initialize: function() {
        var _this = this;
        return this.listenTo(this.model, 'change', function() {
          return _this.render();
        });
      }
    });
    AllModelsView = Backbone.View.extend({
      template: function(json) {
        return "<div><h2>All Models</h2>" + (JSON.stringify(json)) + "</div>";
      },
      initialize: function() {
        var _this = this;
        this.listenTo(this.collection, 'reset', function() {
          return _this.render();
        });
        this.listenTo(this.collection, 'add', function() {
          return _this.render();
        });
        return this.listenTo(this.collection, 'remove', function() {
          return _this.render();
        });
      }
    });
    CollectionModelView = Backbone.View.extend({
      template: function(model) {
        return "<pre>" + model.id + ": " + model.collection.length + " " + (model.collection.map(function(model) {
          return model.id;
        })) + "</pre>";
      },
      templateHelpers: function() {
        return {
          collection: this.model.get('collection').toJSON()
        };
      },
      initialize: function() {
        var _this = this;
        this.listenTo(this.model.get('collection'), 'reset', function() {
          return _this.render();
        });
        this.listenTo(this.model.get('collection'), 'add', function() {
          return _this.render();
        });
        this.listenTo(this.model.get('collection'), 'remove', function() {
          return _this.render();
        });
        return this.listenTo(this.model, 'change', function() {
          return _this.render();
        });
      }
    });
    AllCollectionsView = Backbone.View.extend({
      template: function(json) {
        return "<div><h2>All Collections</h2>" + (JSON.stringify(json)) + "</div>";
      },
      itemView: CollectionModelView,
      initialize: function() {
        var _this = this;
        this.listenTo(this.collection, 'reset', function() {
          return _this.render();
        });
        this.listenTo(this.collection, 'add', function() {
          return _this.render();
        });
        return this.listenTo(this.collection, 'remove', function() {
          return _this.render();
        });
      }
    });
    view = new AllCollectionsView({
      collection: ALL_BACKBONE._collectionsAsCollection
    });
    $('body').prepend(view.render().$el);
    view = new AllModelsView({
      collection: ALL_BACKBONE._modelsAsCollection
    });
    $('body').prepend(view.render().$el);
    SOCKET.emit('STATE?');
    this.Collection = new Backbone.Collection();
    return this.Collection.url = '/foo/bar';
  });

}).call(this);
